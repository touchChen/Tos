1、整个流程： 1）boot 加载 loader
              2）loader 加载 kernel
	     3）kernel 开始使用 c语言
			  
2、文件格式： 1）boot 与 loader 是 fat12
              2）kernel 是 elf


载入文件中发现的问题：
   根目录下查找到要载入的文件，会把根目录下的一个个扇区导入到指定的内存地址，代码里我们使用的这个内存地址是临时借用了即将要存放加载文件的地址
而一个文件项在根目录下占20h个字节，在内存中会做 and 20h的操作，所以要存在加载文件的内存地址必须是20h的倍数	  
			  
c语言 数组的地址与数值名一样

resb 指令，给未使用的段进行初始化工作，是条伪指令

popfd 指令 弹出的值覆盖 eflags寄存器，pushfd 压入堆栈

eflags 寄存器：按位寄存状态，包括通用状态和系统状态
       其中常用的通用状态位包括: zf、df
	   ZF标志：计算的结果为0则将为1，反之为0
	   DF标志：该方向标志，指示串指令自动(主要：LODS\STOS)自动递增(减)
	           而设置和清除DF标志的指令是STD及CLD
           IF标识：中断允许标识，可用屏蔽由NMI引脚接受的外部中断


在loader模块 jmp 到kernel 模块的过程中，寄存器的值没变


中断堆栈 eflags 的相关性  sti 设置 IF 位  cli命令
hlt 指令


开机启动过程中，加载Bios的中断向量表进入内存的ox00000开始地址。中断向量有256个,每个中断占4个字节，
其中2个字节是段址，2个字节是偏移地址，所有的向量共占1k空间（0~400h）


函数指针,关键定义函数的参数和返回值

